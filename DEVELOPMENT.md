##Setting up objects
*April 11 - April 19*
The first thing I wanted to do was create the three necessary objects that I would be using for my backend. First was the Metabolite object, which held an int describing the frequency of it, and then two strings for naming. Next was a reaction object which has a kcat value, a name and two vectors of metabolites, one for reactants and one for products. For simplicity of designed I decided that if a reaction had an equation like 2A + B -> C, then my reactant vector would store {A, A, B}, rather than enumerating the number of A molecules. Third was an enzyme object, which contained a name and a vector of reactions. During this time I experimented with developing in vim and did research to write a Makefile. I also wrote tests for all objects.

##Implementation of Json functionality
*April 21 - April 25*
I became aware that hardcoding all of the variables from the journal article I was using would be incredibly difficult and messy. I felt compelled to store everything in a JSON file. After some research I decided to use the RapidJSON library and integrated it into my project. I made a 'FileToString()' method to pull information from the JSON and began experimenting with reading JSON information. RapidJSON is not automatic like gson and it took a lot f experimentation to realise that values were stored in something called a DOM tree. I created a Pathway object to store my Metabolites, Reactions and Enzymes and then created a Pathway construtor that took in a filename string (ie a JSON). I decided that I wanted to store all of the Metabolites and Reactions in a seperate vector, not just within the Enzyme class, because different reactions contain the same metabolites and multiple enzymes can carry out the same reactions. This design choice seemed the most elegant, but it required me to write StringToMetabolite() and StringToEnzyme() methods. I found this part of my project to be quite challenging.

##Bringing the flowchart to life  - making reactions occur
*April 29*
Fundamentally, a reaction is simply removing a particle from the reactants and adding a particles to the products. However, rate constants make things more complicated as well as the fact that there are different orders of reactions, a field I stored as an enum ReactionType. Though I implemented kcat accuracy (a measure of how many reactions occur per second), I treated all reaction types equally, because I will not learn physical chemistry until my senior year.
Before I began 'reacting' I realised that I had been storing information about how many particles there were as concentration, rather than as literal numbers of particles. Thus I made a ConcToNumParticles() in my Metabolite file, but outside of the object, because information about volume from the Pathway needed to be passed in.
Initially, I created RmParticle() and AddParticle() methods when I created my Metabolite object, but I realised these were unusable because I needed to make a seperate copy of all of the metabolites, predict reactions that may occur and then apply them simultaneously. Thus, I created a std::map<Metabolite, long> where the long repreented the current number of particles. I refactored my num_particles_ field to init_num_particles_ which later became useful when calculating colour and comparing current particle numbers with initial particle numbers. Although ideally I would've liked to hold the IncrementTime() method in my Reaction file, this wasn't working out because my metabolite-long map was stored in the Pathway object.

##Integrating front-end visualisation
*April 27 - April 30*
Though I had begun my project using vim, I later switched to CLion because I found I was much more productive using it. For front end development, I used XCode and thus switched between IDEs for the remainder of development. I used the project generator and ofsnake for reference. I realised I would need to encode the locations of the Enzymes and Metabolites and thus modified my JSON file to hold x_pos and y_pos fields. I hand drew out the reactions from the paper on graphing paper and encoded coordinates. Interestingly, not all of the graph included in the paper had information, so my graph is smaller.
To show reactions, I used ofDrawArrow with an arrow head of size 0.0. I took note from ofsnake and split up my draw methods.
Visualising the variation in colour confused me but from experimenting in PowerPoint I realised that I needed to keep the desired colour (red for Metabolites, blue for Enzymes) constant and high, and then simply toggle the non-desired colour to get the effect I wanted. I decided against my initial idea of having a rainbow spectrum because I wanted to differentiate between Enzymes and Metabolites. Instead, I just liberally used the colour.getInverted() method and tried to have every colour on the final screen.
For the toolbar, I tried to use the ofxgui library but I disliked how bulky setup was and I was having issues getting the logic to work. Instead I resorted to using a simple boolean to change SimulationState between START, IN_PROGRESS, and PAUSED.

##Improving design choices and debugging
*April 28 - May 1*
-When implementing the react() method, I realised that I was going to be passing a lot of data between methods. Although I know that the best strategy of improvin performance is to write, and then improve the slow parts, I also wanted my code to be agile, even if I hadn't proved that it was slow yet. Thus, I changed all of my vectors of Metabolites, Reactions and Enzymes to be vectors of pointers. I was confused and thought I also had to write the Big 5, but after realising that I was passing my test cases without these, I commented out the half-finished attempts. My programme does not require a destructor because all memory required is declared at the very start of running and needed until the whole program is exited.
-I also realised I had made a design error by declaring num_particles_ to be an int. Because I am dealing with incredibly large number, I kept getting integer overflow. This was solved partially by switching to longs. I also modified my ConcentrationToNumParitcles() method to produce a smaller number than scientifically accurate, but I left the scientifically accurate code in, in case I ever modify this program to deal with truly large numbers.
-Finally, after running my simulation, I realised that I had never tested for or considered what happens when a Metabolite runs out. To guard against this I made a CanReact() method. Unfortuanately, I had to place it in my Pathway object so that it could access information about the <Metabolite, long> map. The method returns false when there arent enough particles for a reaction to occur.
